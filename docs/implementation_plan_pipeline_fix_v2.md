# ゴミ取りモードの抜本的修正とパイプライン統合・詳細設計書

## 1. 目的と背景
現在の「ゴミ取りモード」および「位置調整」の処理は、相互に独立して生データ（`input_black/white`）を参照しており、以下の不整合（サイロ化）が発生しています。
- **ソリッド消失**: ゴミ取りをリセットしたり位置調整を確定したりすると、`calculate_alpha_zero` や `finalize_trash_matte` が生データからαを再計算するため、既に適用済みのソリッド（不透明化）が無視される。
- **投げ縄消失**: 位置調整の確定時、内部的に `init_trash_mode` が呼ばれ、`mask_buffer`（投げ縄情報）が強制的にリセット（255埋め）される。
- **処理の冗長性**: プレビュー（`update_trash_matte_fast`）時に行われるRGB計算が、アルファ表示モード等では不要である。

本修正では、`alpha_zero_buffer` を**「画像とオフセット、およびソリッド適用が確定した唯一の絶対的な状態（マスターステート）」**と定義し、すべての後続処理をこのマスターからの派生として再構築します。

---

## 2. バッファ運用の新定義（パイプライン）

### A. alpha_zero_buffer (Master State)
- **役割**: 位置調整済みのα値 + ソリッド適用結果を保持。
- **更新タイミング**:
    1. 背景画像（白黒）入力時
    2. ロジック（計算式）変更時
    3. 位置調整の「確定」時（生データから計算し、ソリッドを再適用）
    4. 「ソリッド適用」ボタン押下時

### B. mask_buffer (User Interaction)
- **役割**: ユーザーが投げ縄で描画した「残す/消す」のマスク（0-255）。
- **更新タイミング**:
    1. 投げ縄ツールによる描画（追加・削除）
    2. ゴミ取りモードの「リセット」ボタン押下時（明示的な255埋め）
    ※ `init_trash_mode` 等の内部処理では**絶対にリセットしない**。

### C. alphaB1 / soft_mat_buffer / hard_mat_buffer (Derivatives)
- **役割**: ゴミ取り表示用の派生バッファ。
- **生成式**: `alpha_zero_buffer * mask_buffer (閾値処理済み)`

---

## 3. 具体的な変更内容 (Rust/WASM)

### 工程 1: `init_trash_mode` の適正化
- **[変更前]**: `mask_buffer` を 255 で初期化している。
- **[変更後]**: `mask_buffer` の初期化コードを削除。これにより、モード遷移や位置確定後もユーザーが描いた投げ縄領域が維持される。

### 工程 2: `update_trash_matte_fast` のロジック刷新
- **[変更前]**: `alpha_zero_buffer` を加工して `soft/hard/alphaB1` すべてに書き込んでいる。
- **[変更後]**: 
    1. 全ピクセルのアルファのみ 0 クリア。
    2. ガーベージマット範囲内において、`alpha_zero_buffer` のアルファ値に対し、`threshold` と `mask_buffer` を適用。
    3. 必要最小限のバッファのみ更新（例：アルファ表示モードなら RGB 255 固定を維持し計算をスキップ）。

### 工程 3: `finalize_trash_matte` のマスターステート基準化
- **[変更前]**: `compute_pixel_raw` で生データから再計算（ソリッド情報が消える原因）。
- **[変更後]**: 
    1. `alpha_zero_buffer` をベースに `threshold` 以下のピクセルを 0 透明化。
    2. さらに `mask_buffer` を乗算して透過を反映。
    3. 結果を `alphaB1` へ書き込む。これによりソリッド適用状態からゴミ取り結果が正しく減算される。

### 工程 4: `calculate_alpha_zero` の整合性伝播
- **[変更前]**: 最後に `init_trash_mode` を呼び、投げ縄を破壊していた。
- **[変更後]**: 
    1. `alpha_zero_buffer` の更新（生データ + ソリッド再適用）は維持。
    2. `alphaB1.copy_from_slice(&alpha_zero_buffer)` を実行。
    3. 投げ縄を破壊しない専用の同期処理（`update_trash_matte_fast` 相当）を呼び出し、表示系バッファを整合させる。

---

## 4. 実行手順（実装ロードマップ）

1.  **[Rust]** `src/lib.rs` の `init_trash_mode` から `mask_buffer` のリセットループをコメントアウト。
2.  **[Rust]** `finalize_trash_matte` を `alpha_zero_buffer` 参照型に全面書き換え。
3.  **[Rust]** `update_trash_matte_fast` のクリア処理（`Step 1`）を最適化し、ループ内の計算を簡略化。
4.  **[Rust]** `calculate_alpha_zero` 内の `init_trash_mode()` 呼び出しを、投げ縄非破壊型の同期処理に置き換え。
5.  **[WASM]** `build.ps1` を実行し、ビルド。
6.  **[JS]** `ImageProcessor.js` 側で追加の投げ縄リセットが必要な場合（「ゴミ取りリセット」ボタンなど）のみ、明示的なリセット命令を実装。

---

## 5. 検証プラン（机上デバッグ）

### テストケース A: ソリッド適用後のゴミ取りリセット
1. ソリッドを適用（`is_solid_applied = true`, `alpha_zero_buffer` が不透明化）。
2. ゴミ取りモードでスライダーを動かす。
3. **期待値**: ソリッド部分が維持されたまま、ノイズだけが消える。

### テストケース B: 投げ縄描画後の位置調整確定
1. 投げ縄ツールで特定領域を消す（`mask_buffer` に 0 を書き込む）。
2. 位置調整モードに入り、確定（Enter）を押す。
3. **期待値**: 画像の位置はズレるが、消した領域（`mask_buffer`）はリセットされずに残っている。

### テストケース C: 位置確定後のソリッド維持
1. ソリッドを適用済み。
2. 位置調整を確定。
3. **期待値**: `calculate_alpha_zero` 内でソリッドが再適用され、結果が `alphaB1` へ伝播される。
