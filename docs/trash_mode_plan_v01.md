# ゴミ取りモード：最終実装計画書 (v01_Final)

アーロン様、度重なるご期待と詳細なご指導、誠にありがとうございます。
過去のロールバックの教訓を刻み込み、二度とカオスに陥ることのない「決定版」の配線図をここにまとめました。

## 1. 核心設計：バッファ構成
役割を名前に直結させ、データの流れを一方通行（Reactive）にします。

| バッファ名 | 役割 | 備考 |
| :--- | :--- | :--- |
| `alpha_zero_buffer` | **元祖** | ロード時の初期計算結果。不変のソース。 |
| `alphaB1` | **製品カラー版** | 最終的な透過PNG。出力・オーバーレイ用。 |
| `soft_mat_buffer` | **ソフトマット** | グラデーション可視化用。RGB面は `1` 固定。 |
| `hard_mat_buffer` | **ハードマット** | 2値(0/255)可視化用。RGB面は `1` 固定。 |
| `mask_buffer` | **手動マスク** | なげなわ操作の結果のみを保持する1chバッファ。 |

## 2. 管理フラグ：JS状態管理
| フラグ名 | 状態 | 意味 |
| :--- | :--- | :--- |
| `typesOfAlpha` | `'soft'` / `'hard'` | 画面に表示するマスクの種類。 |
| `overlayMode` | `true` / `false` | 製品版(`alphaB1`)を重ねるか否か。 |

## 3. 具体的な内部ワークフロー

### A. 進入時（初期化）
1. `init_trash_mode` を実行。
2. `alpha_zero_buffer` を `alphaB1` にコピー。
3. `soft/hard_mat_buffer` の RGB 平面を `1` で塗りつぶす。
4. 背景を一度「強制的に黒」へ設定。

### B. 常駐描画ループ（ゼロコピー）
JS 側は `processor.get_active_ptr()` を呼び出し、現在のフラグ(`overlayMode`, `typesOfAlpha`)に基づいた適切なバッファのポインタを取得して `RenderEngine` に流し込みます。メモリコピーは一切発生しません。

### C. 位置調整（Alignment）時のリアクティブ再計算
1ドットの移動ごとに、Rust 側で以下の処理を全面（フルキャンバス）に実行します。
1. **アルファ再錬成**: ズレた座標で黒/白画像から Alpha を再計算（引き算ベースの高速演算）。
2. **全面上書き**: 計算漏れや残像を防ぐため、常にキャンバス全体を最新の計算結果で埋め尽くします。
3. **一時的マット解除**: 位置合わせに集中するため、調整中はガーベージマットの切り落としを解除します。

### D. マスク確定・パラメータ更新（1-Pass 同期）
なげなわ操作を離した時や、閾値スライダーを動かした時、以下の単一ループを実行します。
```rust
// 擬似コード
for px in 0..len {
    let a = calc_base_alpha(px); // 閾値・ガーベージ適用
    let final_a = apply_mask(a, px); // なげなわマスク合成
    
    soft_mat_buffer[px].A = final_a;
    hard_mat_buffer[px].A = if final_a > 0 { 255 } else { 0 };
    if overlay_mode { alphaB1[px].A = final_a; }
}
```

## 4. 安全対策と品質保証
- **Straight RGB の復元**: 位置調整の確定時（Enter）に、最新のオフセットに基づき `alphaB1` の **RGBチャンネルも全て正しく再計算** し、最高画質を維持します。
- **カオス化の防止**: ゴミ取りモード専用の処理は `trash_` という接頭辞を付けた独立した関数群として実装し、既存の基本モードの安定性を損なわないようにします。

---
アーロン様、この「決定版」において、全ての懸念事項を技術的な解決策で上書きいたしました。
承認をいただけましたら、丁寧、かつ迅速に実装の第一歩を踏み出させていただきます。
