# Aaron Alpha 内部ワークフロー解説：ゴミ取りモード（Trash Mode）完全版

アーロン様、ゴミ取りモードの全機能を網羅し、データの流れと内部処理を詳細に記述した「完璧な」ワークフローを作成いたしました。

---

## 1. モードの役割とデータ基盤
ゴミ取りモード（Trash Mode）の主目的は、基本モードで抽出された透過データから、不要な浮遊ゴミや背景の残りカスを排除し、**製品版の透過画像（alphaB1）** を完成させることです。

*   **基点バッファ**: `alpha_zero_buffer` (初期計算結果)
*   **製品版バッファ**: **`alphaB1`**
    *   このバッファは常に **Straight RGB + Alpha** の RGBA 情報を保持し、オーバーレイ表示や出力の最終結果となります。

---

## 2. ゴミ取りの全機能と計算ロジック

### ① 位置補正（Alignment Adjustment / Offset）
黒背景画像と白背景画像のズレを物理的に解消し、RGB/Alpha を根底から再生成します。
*   **確定実行**: `finalize_trash_mode` が走り、新しいオフセットに基づき `alpha_zero_buffer` からサンプリングして、**Straight RGB と Alpha を同時に再算出** し、`alphaB1` を上書きします。

### ② ガーベージマット & 閾値処理
*   **処理**: `alphaB1` の指定範囲の **Alpha チャンネルのみを操作** します。
*   **可視化**: ユーザーが操作している間、`soft_mat_buffer` または `hard_mat_buffer` の Alpha も同時に更新され、選択中のマットがリアルタイムに描画されます。

### ③ なげなわツール (Mask Editing)
*   **演算**: **`mask_buffer`** に蓄積された操作を、表示バッファおよび `alphaB1` の Alpha 演算に動的に合成します。

---

## 3. レンダリング・パイプライン

JS は描画ループを持たず、WASM メモリ上の適切なポインタを `RenderEngine` に流し込む「ポインタ切り替え方式」を採用します。

### A. 表示バッファの選択ロジック (Rust側)
JS が描画をリクエストする際、以下の優先順位でバッファが選択されます。

1.  **Overlay ON**: `alphaB1` (製品カラー透過画像)
2.  **Overlay OFF & SoftMat**: `soft_mat_buffer` (グラデーション可視化)
3.  **Overlay OFF & HardMat**: `hard_mat_buffer` (2値可視化)

### B. ゼロコピー描画
JavaScript は WASM メモリ上の指定バッファへのポインタを取得し、そのまま `ImageData` としてレンダリングします。ブラウザ側でのコピーやピクセル操作は一切発生せず、スライダー操作に完全に吸い付きます。

### B. 背景の下敷きと合成
描画エンジン（`RenderEngine`）内では、以下の順序でレイヤーが重なります。

1.  **最背面**: キャンバス背景（市松模様、または指定された単色）。
2.  **中面（メイン）**: **`viz_buffer`** から取り出した画像（RGBA）。
3.  **前面**: ガーベージマット境界線、なげなわのプレビュー線などの UI 要素。

---

## 4. メモリ消費量とパフォーマンスの試算

平行バッファ方式を採用（RGBAバッファ7面+マスク1面）した場合の、解像度ごとのメモリ消費量（RAM）の試算です。

| 解像度 | 1バッファのサイズ | 合計メモリ消費量 | パフォーマンスへの影響 |
| :--- | :--- | :--- | :--- |
| **2K (2048x1536)** | 約 12.6 MB | **約 91.3 MB** | 非常に高速。ラグはほぼゼロ。 |
| **FHD (1920x1080)** | 約 8.3 MB | **約 60.1 MB** | 非常に高速。 |
| **4K (3840x2160)** | 約 33.2 MB | **約 240.7 MB** | 現代のPCならば全く問題なし。 |

### 結論
2K〜4K程度の画像であれば、メモリ消費量は最大でも 250MB 程度に収まります。これは現代のブラウザ環境（数GBのRAMが一般的）においては許容範囲内です。このメモリを投資することで、JavaScript のメインスレッドを占有する重いループを排除し、**「スライダー操作に完全に吸い付く」** 極めて高い応答性を実現します。

---

## 4. 状態管理（リセットと永続化）

### 設定のリセット (`btn-reset-trash`)
ユーザーが迷走した際、以下の手順で「初期の透過状態」に復帰させます。
1.  オフセットをロード時の自動補正値に戻す。
2.  ガーベージマット、閾値を 0/5 にリセット。
3.  `alpha_zero_buffer` を `alphaB1` に全コピーして、手動マスク編集を破棄。
4.  基本モードの「ズレのない透過状態」から再スタート可能にする。

### データの永続化
各設定が変更されるたびに、または確定アクション時に `alphaB1` が更新されます。この `alphaB1` は Solid モードへの切り替え時にも引き継がれ、共通のソースとして利用されます。

---

## 結論
ゴミ取りモードとは、**「自動補正された素材（Zero）」に対し、「数値（Matte/Threshold）」と「意図（Lasso）」を掛け合わせ、完成された「透過データ（B1）」を錬成するプロセス** です。
この `alphaB1` が完璧に仕上がることで、初めて高度な Solid モードや正確なエクスポートが可能になります。
