# AaronAlpha アルファ・ストレートRGB計算ロジック解説

本ドキュメントでは、AaronAlphaのソリッドモードにおける「物理的に正しい透過合成」を実現するための数理モデルとアルゴリズムについて解説します。

## 1. 基本コンセプト：アーロンの物理モデル

AaronAlphaの画像処理は、以下の「三段階の領域分離」に基づいて計算されます。

1.  **完全不透明領域 (Alpha = 255)**
    - 元の「黒背景画像 (`input_black`)」の色情報をそのまま採用します。
2.  **完全透過領域 (Alpha = 0)**
    - 色情報は `(0, 0, 0, 0)` として扱われ、背景と完全に置き換わります。
3.  **半透明領域 (0 < Alpha < 255)**
    - この領域の色（ストレートRGB）は、**「現在のアルファ値」に基づいて「元の黒背景画像」から逆算**されます。

## 2. フリンジ（白縁）問題の発生原因

ゴミ取りモード（Trash Mode）で計算されたストレートRGB (`alphaB1`) は、非常に小さいアルファ値で割り算を行って生成されます。

$$StraightRGB = \frac{InputBlack}{TrashAlpha}$$

元の `TrashAlpha` が極小（例：5）である場合、この領域の `StraightRGB` は非常に明るい値（ほぼ純白）として保持されます。
ここにソリッドモードの投げ縄等で「人工的に大きなアルファ値（例：128）」が上書きされた際、この「古い（明るすぎる）ストレートRGB」をそのまま流用すると、画面上に白いフリンジとして浮き出てしまいます。

## 3. 数理アルゴリズム：動的再計算

この問題を解決するため、ソリッドモードのプレビューおよび保存時には以下の条件分岐と再計算ロジック（アーロン理論）を適用しています。

### A. アルファ値の決定
$$NewAlpha = \max(TrashAlpha, SolidAlpha)$$

### B. ストレートRGBの選択ロジック（決定木）

1.  **$NewAlpha = 255$ の場合**
    - $TrashAlpha = 0$ （元々何もない場所）なら、RGBは `(0, 0, 0)`。
    - それ以外なら、RGBは `input_black` の値を採用。

2.  **$0 < NewAlpha < 255$ の場合**
    - **人為的な拡張がある場合 ($SolidAlpha > TrashAlpha$)**:
        - 古いストレートRGBは破棄し、新しいアルファに基づいて再計算する。
        - **計算式**: $OutputRGB = \min(255, \frac{InputBlack}{(NewAlpha / 255.0)})$
    - **純粋なゴミ取りエッジの場合**:
        - ノイズ除去済みの既存バッファ `alphaB1` の値を採用。

3.  **$NewAlpha = 0$ の場合**
    - RGB、Alphaともに `0`。

## 4. 実装コード (Rust)

`rust_core/src/lib.rs` における実装の抜粋：

```rust
let new_a = if solid_a > trash_a { solid_a } else { trash_a };

if new_a == 255 {
    if trash_a == 0 {
        // 白背景を参照せず、完全透過部分は問答無用で黒
        [0, 0, 0, 255]
    } else {
        // 実在する不透明部分は生の画像
        [black_r, black_g, black_b, 255]
    }
} else if new_a > 0 {
    if solid_a > trash_a {
        // アルファが拡張されたなら、input_blackから再逆算（フリンジ防止）
        let ratio = new_a as f32 / 255.0;
        let r = (black_r as f32 / ratio).min(255.0) as u8;
        // ... (G, Bも同様)
        [r, g, b, new_a]
    } else {
        // 純粋なエッジは既存のalphaB1を採用
        [b1_r, b1_g, b1_b, new_a]
    }
}
```

## 5. 結論

このロジックにより、ユーザーが半透明のエッジを投げ縄で塗りつぶしたり広げたりしても、常にその時点の不透明度に応じた「物理的に矛盾のない色（ストレートRGB）」が動的に算出され、美しい合成結果が得られるようになっています。
